{"meta":{"title":"XiaoBendy","subtitle":"","description":"","author":"XiaoBendy","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-02-21T04:43:44.000Z","updated":"2021-02-22T11:42:04.102Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-21T05:03:23.000Z","updated":"2021-02-21T05:06:17.482Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaIO2-字节流","slug":"JavaIO2-字节流","date":"2021-03-06T07:03:27.000Z","updated":"2021-03-07T13:45:19.313Z","comments":true,"path":"2021/03/06/JavaIO2-字节流/","link":"","permalink":"http://example.com/2021/03/06/JavaIO2-%E5%AD%97%E8%8A%82%E6%B5%81/","excerpt":"","text":"IO概述字符流回顾代码案例： 12345678910111213141516171819202122public class CharStreamDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(&quot;a.txt&quot;); //一次读取一个数组的数据 char[] chs=new char[10]; int len=-1; while((len=fr.read(chs))!=-1)&#123; System.out.print(new String(chs,0,len)); &#125; fr.close(); System.out.println(&quot;==============&quot;); FileReader r = new FileReader(&quot;a.txt&quot;); //这里若继续使用上面定义的fr 则输出的结果则是空 //一次读取一个字符 int ch; while((ch=r.read())!=-1)&#123; System.out.print((char)ch); &#125; r.close(); &#125;&#125; 运行结果： 1234567Hello World!Hello World!Hello World!==============Hello World!Hello World!Hello World! 数据的本质数据在传输的过程中，一切数据（文本，图像，声音等)最终存储的均为一个个字节，即二进制数字。所以数据传输过程中，使用二进制数据可以完成任意数据的传输 我们想一个文件中存储一定的数据，如果使用文本方式打开，则会以文本的方式解释数据。如果以视频的方式打开则会以视频的方式解释数据。音频，可执行文件等都是如此。所以在文件传输过程中，我们要时刻明确，传输的始终是二进制数据。 字节输入流和字节输出流字节输出流输出流：OutputStream抽象类 FileOutputStream基本输出流 构造方法： public FileOutputStream(String name） 创建输出流操作得分目标 public FileOutputStream(String name,boolean append) append为true时代表每次写入都向文件末尾追加，为False则覆盖原有内容 操作方法： write(int n) 输出一个字节； write(byte[] b) 输出一个字节数组 write(byte[] b,int off,int len) 输出字节数组的一部分 close() 释放IO占用的windows底层资源 代码案例： 12345678910111213141516public class OutputStreamDemo &#123; public static void main(String[] args) &#123; try &#123; OutputStream os=new FileOutputStream(&quot;test.txt&quot;,true); //true表示输出内容是在文件末尾追加内容的 os.write(97); //输出的是字符a byte[] b=&#123;97,98,99&#125;; //输出的是abc os.write(b); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字节输入流输入流： InputStream 抽象类 FileInputStream 基本输入流构造方法： public FileInputStream(String name)操作方法： int read(); 读取一个字节 返回字节内容本身 读取到文件末尾返回-1 int read(byte[] b) 读取一个字节数组 close() 释放资源 代码案例： 123456789101112public class InputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; InputStream fis=new FileInputStream(&quot;test.txt&quot;); //一次读取一个字节 也可以一次读取一个字节数组 System.out.println(fis.read()); int c=-1; while((c=fis.read())!=-1)&#123; System.out.println(c); &#125; &#125;&#125; 运行结果： 123497979899 文件复制与高效流文件复制方式1：不使用字节数组 即一次读取一个字节方式2：使用字节数组 一次读取一个字节数组 高效字节流Java在常规IO的基础上，提供了更为高效的缓冲流，如下：高效字节缓冲流：BufferedInputStream/BufferedOutputStream高效流使用普通流对象作为构造方法参数。将普通流包装，提供高效的装饰高效流write写出数据时，写出位置为缓冲区，并非目标资源。需要通过flush刷新方法将缓冲区的内容写出到目标文件中。并且高效输出流的关闭方法会自动调用flush方法 高效原理：缓冲区临时存储多个数据，然后一次调用底层资源，减少代用底层资源的次数，也即调用中断次数，从而提高程序运行速度。 代码案例： 123456789101112131415public class BufferedByteStreamDemo &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(&quot;test.txt&quot;); BufferedInputStream bis = new BufferedInputStream(fis); int c = bis.read(); System.out.println(c); byte[] b=new byte[10]; int len=-1; while((len=bis.read(b))!=-1)&#123; System.out.println(new String(b,0,len)); &#125; &#125;&#125; 运行结果： 1297abc 转换流操作纯文本文件时，使用字节流对于程序来说过于繁琐，程序员更偏好操作字符。所以当面对一些字节流的操作时，我们可以将其转换成字符流再进行操作，这样便非常方便了。 Reader： InputStreamReader可以完成字节输入流转换成字符流Writer： OutputStreamWriter可以完成字节输出流转换成字符输出流。 由上边可以知道，转换流是字符流的一种，创建对象是传入对于的字节流对象即可完成转换动作。 转换流同样使用了包装的思想，其构造方法接受的同样为IO流对象，并非某个文件资源。关闭转换流的同时即关闭了对应的字节流。 OutputStreamWriter12345678910111213//利用转换流向test.txt中写入“hello:中国”public class OutputStreamWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流 FileOutputStream fos = new FileOutputStream(&quot;test.txt&quot;, true); OutputStreamWriter osw = new OutputStreamWriter(fos); osw.write(&quot;hello:中国&quot;); //向字节流中写入字符串 osw.close(); &#125;&#125; InputStreamReader需求：已经具备字节流，绑定了IO资源。需要将字节流转换字符流 此时，可以使用转换流，接受一个字节流对象，进行字符流的操作，转换流本身就是字符流。 12345678910111213public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(&quot;test.txt&quot;); InputStreamReader isr = new InputStreamReader(fis); int b=-1; while((b=isr.read())!=-1)&#123; System.out.println((char)b); &#125; fis.close(); &#125;&#125; 运行结果： 123456789101112aabchello:中国 编码表编码表概述我们知道计算机底层数据存储的都是二进制数据，而我们生活中各种各样的数据，如何才能和计算机中存储的二进制数据对应起来呢？？ 这时美国就把他们的每一个字符和一个整数对应起来，就形成了一张编码表，美国他们的编码表就是ASCII表。其中就是各个英文字符对应的编码 编码表：就是生活中字符和计算机二进制的对应关系表。 ASCII：一个字节中的7位表示。对应的字节就是正数：0xxxxxxx。 ISO-8859-1：拉丁Latin码表，用一个字节8位表示。1xxxxxxx:负数 GB2312：简体中文码表。包含6000-7000中文和符号。用两个字节表示。两个字节第一个字节就是负数，第二个字节可能是正数 GBK：目前最常用的中文码表，2万的中文和符号。用两个字节表示，其中一部分文字，第一个字节开头是1，第二个字节开头是0. GB18030：最新的中文码表，目前还没有正式使用。 Unicode：国际标准码表：无论是什么文字，都用两个字节存储。 Java中char类型用的就是这个码表：char c=’a’ ;占用两个字节 UTF-8：基于Unicode，一个字节就可以存储数据，不用两个字节存储，而且这个码更加标准化，中文一般使用3个字节 能识别中文的码表：GB2312，GBK，Unicode，UTF-8 乱码问题A：乱码：当字符与字节转换过程中使用了不同的码表，会造成乱码的情况 B：在字符串中：当我们将字符串转为对应的数字字节时，需要指定码表，则存储为该字符该码表对应的数字字节，如果使用了其他码表重写翻译回字符串，则拼写的新字符串回出现乱码 C：在IO中：与字符串编码表使用类似，当以某个码表写出字节数据时，又使用另外的码表展示，就会出现乱码。 将字节流设置指定编码的字节流： public Output StreamWriter(OutputStream out,String charsetName); public Input StreamReader(InputStream in,String charsetName); 代码实例： 12345678910111213141516171819public class CharSetDemo &#123; public static void main(String[] args) throws IOException &#123; //使用UTF-8的方式将字符输出到文件中 FileOutputStream fos = new FileOutputStream(&quot;test.txt&quot;); OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;); osw.write(&quot;你好&quot;); osw.close(); //注意这里需要关闭osw（在关闭对象资源之前会先清空缓存） 否则下面可能不会输出任何内容 //如果使用UTF-8的方式写出两个汉字（6个字节），在那个写出的文件中观看时乱码了 这时在使用UTF-8的方式从那个文件中读回就不会乱码了 FileInputStream fis = new FileInputStream(&quot;test.txt&quot;); InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;); //这里若使用GBK的方式读会就会出现乱码 int ch=-1; while((ch=isr.read())!=-1)&#123; System.out.print((char)ch); &#125; isr.close(); &#125;&#125; 其他流序列化和反序列化概述用于向流中写入对象的操作流ObjectOutputStream 称为序列化流。用于从流中读取对象的操作流 ObjectInputStream 称为反序列化流。 特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象 ObjectOutputStream 序列化流 public final void writeObject(Object o); ObjectInputStream 反序列化流 public final Object readObject(); 每个被序列化操作的类型必须实现Serializable接口（使其具备序列化功能的标记接口，不需要实现任何方法）。 对象序列化流ObjectOutputStreamObjectOutputStream将Java对象写入到OutputStream，利用输出流将对象写入到指定文件中。 代码案例： 123456789101112131415161718public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Person person = new Person(&quot;Jack&quot;,&quot;22&quot;); //利用OutputStream将Person对象写入到指定文件中 FileOutputStream fos = new FileOutputStream(&quot;personObject.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(person); oos.close(); //利用InputStream从泰国指定文件中读取对象 FileInputStream fis = new FileInputStream(&quot;personObject.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Person o = (Person)ois.readObject(); System.out.println(o.getName()); System.out.println(o.getAge()); &#125;&#125; 打印流打印流添加输出数据的功能，使他们能够方便打印各种数据值表示形式 打印流只有输出流，没有输入流： ​ PrintStream 字节打印流 调用println 方法时自动刷新 ​ PrintlnWriter 字符打印流 指定自动刷新开关后，调用prinln方法时自动刷新，无序手动调用flush() 方法 第三方工具CommonsIO导入classpathA：加入classpath的第三方jar包内的class文件才能在项目使用 B：创建lib文件夹 将commons-io.jar拷贝到lib文件夹 右键点击Commons-io.jar，Build Parth —-&gt;Add to Build Path Filename Utils这个工具是用来处理文件名（包含文件路径）的，他可以轻松解决不同不同操作系统文件名称规范不同的问题 常用方法： ​ getExtension(String path) 获取文件的扩展名​ getName() 获取文件名​ isExtension(String fileName,String ext) 判断fileName是否是ext后缀名 FileUtils提供文件操作（移动文件，读取文件，检查文件是否存在等等）的方法。 常用方法： ​ readFileToString(File file) 读取文件内容，并返回一个String​ writeStringtoFile(File file,String content) 将内容content写入到file中​ copyDirectoryToDirectory(File srcDir,File destDir) 文件夹复制​ copyFile(File srcFile,File destFile) 文件复制","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础 JavaIO 字节流","slug":"Java基础-JavaIO-字节流","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-JavaIO-%E5%AD%97%E8%8A%82%E6%B5%81/"}]},{"title":"Java集合2","slug":"Java集合2","date":"2021-03-05T06:22:16.000Z","updated":"2021-03-05T14:35:15.359Z","comments":true,"path":"2021/03/05/Java集合2/","link":"","permalink":"http://example.com/2021/03/05/Java%E9%9B%86%E5%90%882/","excerpt":"","text":"双列集合MapMap概述双列集合是每个元素都有建与值两个部分组成和集合，记录的是键值对对应关系。即通过键可以找到值。 常用子类： 最常用的双列集合是Map下的子类HashMap。 Hashtable也是Map集合的一种已被HashMap取代。Map集合的特点，如是否可以重复，是否有序仅作用在键上，如**HashMap集合的键不可重复，只可以重复** Map基本使用A：Map（HashMap）的使用：创建对象时加入两个泛型。 Map（K，V） 其中K是此映射所维持的键的类型；V是映射值的类型。B：常用方法： public V put(K key,V value) 加入元素，则新值会覆盖掉旧值。 public V get(Object key) 根据键找到值 public Set&lt;K&gt; keySet() 返回所有键的集合 public Collection&lt;K&gt; values() 返回所有值的集合 代码案例： 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建双列集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //向集合添加元素 map.put(&quot;及时雨&quot;,&quot;宋江&quot;); map.put(&quot;玉麒麟&quot;,&quot;卢俊义&quot;); map.put(&quot;智多新&quot;,&quot;高俅&quot;); map.put(&quot;智多新&quot;,&quot;吴用&quot;); //这里新值会覆盖上面的旧值 System.out.println(map); String name=map.get(&quot;智多新&quot;); System.out.println(name); System.out.println(map.get(&quot;母夜叉&quot;)); System.out.println(map.keySet()); &#125;&#125; 双列集合Map的遍历方式1：使用Map集合的keySet()方法获取所有的键值，然后通过键获取值方式2：使用Map集合的entrySet()方法获取所有键值对对象的集合，然后遍历键值对象的集合，获取每一个键值对对象，根据键值对对象的获取键和值。enterySet()方法说明： Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()方法用于返回某个集合所有的键值对对象。 Map.Entry是Map的内部接口，将键和值封装成了Entry对象并存储在Set集合中。可以从一个Entry对象中获取一个键值对的键和值。 Entry中的方法如下： K getKey()获取键 V getValue()获取值 12345678910111213141516171819202122232425262728293031public class MapDemo2 &#123; public static void main(String[] args) &#123; //创建双列集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //向集合添加元素 map.put(&quot;及时雨&quot;,&quot;宋江&quot;); map.put(&quot;玉麒麟&quot;,&quot;卢俊义&quot;); map.put(&quot;智多新&quot;,&quot;高俅&quot;); map.put(&quot;昵称&quot;,&quot;名字&quot;); //使用keySet方法遍历 Set&lt;String&gt; keys = map.keySet(); Iterator&lt;String&gt; it = keys.iterator(); while(it.hasNext())&#123; String next = it.next(); String name = map.get(next); System.out.println(next+&quot;:&quot;+name); &#125; System.out.println(&quot;------------------&quot;); //使用entrySet()方法遍历 Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;String, String&gt; next = iterator.next(); String key = next.getKey(); String value = next.getValue(); System.out.println(key+&quot;:&quot;+value); &#125; &#125;&#125; LinkedHashMapLinkedHashMap特点：**链表结构，保证元素有顺序；Hash结构保证保证元素唯一性；以上这些特点值是针对键其作用**。LinkedHashMap底层是链表实现的可以保证怎么存就怎么取 1234567891011121314151617public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put(&quot;近平&quot;,&quot;丽媛&quot;); map.put(&quot;路人甲&quot;,&quot;路人乙&quot;); map.put(&quot;Jack&quot;,&quot;Rose&quot;); map.put(&quot;Jack&quot;,&quot;Lily&quot;); System.out.println(map); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); for(Map.Entry&lt;String,String&gt; entry:entries)&#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&#x27;:&#x27;+value); &#125; &#125;&#125; 运行结果： 1234&#123;近平=丽媛, 路人甲=路人乙, Jack=Lily&#125;近平:丽媛路人甲:路人乙Jack:Lily 集合其他相关可变参数Collections中有一个方法可以一次加入多个元素 public static&lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T …..elements); 该方法使用到了可变参数，即定义是并不知道传入多少个实际参数。此时定义成…….的方式，此时可以在调用该方法时，一次传入多个参数。传入的多个参数将自动组织成数组，我们只要操作生成的数组即可。注意：可变参数只能放在最后定义。可变参数方法的参数本质是数组，所以不可以与数组类型参数重载 Collections与Collection的区别： Collection是集合类的最上级接口，继承与它有关的接口主要有List与Set。 Collections是针对集合类的一个帮助类，它提供一些列静态方法对各中集合的搜索，排序，线程安全等操作。 123456789101112131415161718192021222324//可变参数的使用public class ArgsDemo &#123; //自定义可变参数 public static int add(int... a)&#123; int count=0; for(int i=0;i&lt;a.length;i++)&#123; count+=a[i]; &#125; return count; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); Collections.addAll(list,&quot;Jack&quot;,&quot;Rose&quot;,&quot;Lisa&quot;); System.out.println(list); System.out.println(&quot;=====================&quot;); int count = add(10, 20, 20, 30); System.out.println(count); int[] arr=&#123;10,20,30,40&#125;; System.out.println(add(arr)); //可变参数本质就是数组 所以可变参数也不可以与数组重载 &#125;&#125; 运行结果： 1234[Jack, Rose, Lisa]=====================80100 Collections的shuffe方法shuffe方法的作用：打乱集合元素顺序 Collections的sort方法A：sort方法的作用：对集合元素进行排序B: sort方法签名 public static &lt;T&gt; void sort(List&lt;T&gt; list) Collections的二分查找binarySearch方法签名：public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key) ; 查找集合中指定元素的索引。 注意在二分查找之前需要先对集合进行排序 123456789101112public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,2,4,1,6,3,9); Collections.sort(list); //在进行二分查找之前需要先进行排序 System.out.println(list); //输出排序后的结果 int index = Collections.binarySearch(list, 4); //返回指定元素的索引 System.out.println(index); &#125;&#125; 运行结果： 12[1, 2, 3, 4, 6, 9]3 Arrays的toString方法toString的方法签名：public static String toString(Xxx[] a) 返回字符串内容。 代码案例： 12345678910public class ArraysDemo &#123; public static void main(String[] args) &#123; String[] arr=&#123;&quot;Jack&quot;,&quot;Rose&quot;,&quot;Lisa&quot;&#125;; System.out.println(arr); //调用Arrays的toString() System.out.println(Arrays.toString(arr)); &#125;&#125; 运行结果： 12[Ljava.lang.String;@1b6d3586[Jack, Rose, Lisa] 数组转为集合使用Arrays的asList方法，可将数组转为List集合。其方法签名为：public static&lt;T&gt; List&lt;T&gt; asList(T…a)注意：使用asLIst转成的集合，不能添加或者删除元素。否者会出现UnsupportedOperationException异常 1234567891011//asList 数组转成集合public class ArraysAsListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList(&quot;Jack&quot;, &quot;Rose&quot;, &quot;Lisa&quot;); System.out.println(list); //下面向集合添加元素出现异常 list.add(&quot;Mike&quot;); &#125;&#125; 运行结果： 12[Jack, Rose, Lisa]Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException 集合转成数组集合ArrayList数组使用的是，ArrayList中的toArray()方法 12345678910111213public class ArrayListToArray &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,&quot;Rose&quot;,&quot;Lisa&quot;,&quot;Jack&quot;); //使用ArrayList中的toArray方法将集合转为数组 Object[] objects = list.toArray(); //输出数组 **需要将数组转为字符串 System.out.println(Arrays.toString(objects)); System.out.println(objects); &#125;&#125; 运行结果： 12[Rose, Lisa, Jack][Ljava.lang.Object;@1b6d3586","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础 Map","slug":"Java基础-Map","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-Map/"}]},{"title":"Java集合","slug":"Java集合","date":"2021-03-03T14:37:30.000Z","updated":"2021-03-04T06:42:45.713Z","comments":true,"path":"2021/03/03/Java集合/","link":"","permalink":"http://example.com/2021/03/03/Java%E9%9B%86%E5%90%88/","excerpt":"","text":"LinkedList类LinkedList与ArrayList不同，LinkedList是方便添加或删除的List。实际开发中对一个集合元素的添加和删除经常会涉及到首尾的操作。 LinkedList的特点是添加和删除块，但是查询慢。这是因为LinkedList是链表在添加和删除元素时，只需要修改上一个节点记录的地址值即可；而对于查询则需要遍历到要查询的元素为止。 ArrayList的特点是查询快，添加和删除慢。查询快是由于数组的索引支持，所以可以通过直接计算出元素的地址值，因此可以直接通过元素的地址值获取指定的元素；添加和删除慢是因为ArrayList在添加和删除元素时，在底层会先创建一个新数组，先需要堆数组原有的数组进行拷贝，其次在末尾进行添加或者删除元素。 LinkedList提供了大量首尾操作： public void addFirst(E e); public void addLast(E e); public E getFirst(); public E getLast(); 代码实例如下： 123456789101112131415161718192021222324252627282930313233public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list=new LinkedList&lt;String&gt;(); //添加元素 list.add(&quot;Jack&quot;); list.add(&quot;Rose&quot;); list.add(&quot;Trump&quot;); //获取元素 String name=list.get(1); System.out.println(&quot;第二个元素：&quot;+name); //返回集合的迭代器 Iterator&lt;String&gt; it=list.iterator(); //利用迭代器便利 while(it.hasNext())&#123; String thisName=it.next(); System.out.println(thisName); &#125; System.out.println(&quot;------------&quot;); //使用增强for循环便利 for(String thisName:list)&#123; System.out.println(thisName); &#125; System.out.println(list); //删除 list.remove(); //默认删除第一个元素 也可以通过索引删除指定元素或者删除首尾元素 System.out.println(list); &#125;&#125; 运行结果： 12345678910第二个元素：RoseJackRoseTrump------------JackRoseTrump[Jack, Rose, Trump][Rose, Trump] LinkedList可支持栈结构当然Java也提供专门用于栈结构的类Stack LinkedList对于栈结构提供了如下的方法： push 压栈 pop 弹栈 peek 查询出即将要出栈的元素（栈顶元素），检查有没有要弹出的元素,当栈为空时就返回空值。 代码实例： 1234567891011121314151617181920212223public class StackDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;(); stack.push(&quot;Jack&quot;); stack.push(&quot;Rose&quot;); stack.push(&quot;Lisa&quot;); System.out.println(stack); //获取一个元素 此时，由于是栈结构 所以获取的是最后压栈的元素 String popName=stack.pop(); //这里获取的是Lisa元素 System.out.println(popName); System.out.println(stack); String peekName=stack.peek(); System.out.println(peekName); //peek查看元素不会减少元素 System.out.println(stack); &#125;&#125; 运行结果： 12345[Lisa, Rose, Jack]Lisa[Rose, Jack]Rose[Rose, Jack] 注意这里输出栈时，是从栈顶到栈底依次输出 LinkedList可支持队列结构LinkedList为支持队列元素提供了如下的方法： offer 加入队列 poll 离开队列 peek 查询出即将要离开队列的元素（即队首元素），可检查有没有要离开队列的元素,当队列为空时返回空值null 代码实例： 12345678910111213141516171819202122232425262728public class QueueDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(&quot;Jack&quot;); queue.offer(&quot;Rose&quot;); queue.offer(&quot;Lisa&quot;); System.out.println(queue); //获取队首元素 String pollName=queue.poll(); System.out.println(pollName); System.out.println(queue); String peekName=queue.peek(); System.out.println(peekName); System.out.println(queue); //清空队列 queue.remove(); queue.remove(); //检查是否还有要离开的元素 String name=queue.peek(); System.out.println(name); //队列为空时 peek()返回的是空值null &#125;&#125; 运行结果： 123456[Jack, Rose, Lisa]Jack[Rose, Lisa]Rose[Rose, Lisa]null HashSet类HashSet是Set接口的子类，不包括重复相同的元素，*并且是无序的**，且提供索引，所以不能通过索引获取元素，只能通过迭代器访问数据*** HashSet下还有子类LinkedHashSet,是可预测迭代顺序的Set的集合。 代码实例： 1234567891011121314151617181920212223public class HashSetDemo &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;Jack&quot;); set.add(&quot;Lisa&quot;); set.add(&quot;Rose&quot;); set.add(&quot;Rose&quot;); System.out.println(set); //输出是无序的 //获取元素，只能迭代器 Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; String name = it.next(); System.out.println(name); &#125; System.out.println(&quot;============&quot;); //使用增强for遍历set集合 for(String name:set)&#123; System.out.println(name); &#125; &#125;&#125; 运行结果： 12345678[Rose, Jack, Lisa]RoseJackLisa============RoseJackLisa 注意这里输出结果是无序的，还要记住不能通过索引来访问只能使用迭代器来访问数据 HashSet的简单应用：使用HashSet求一个字符串中一共有几个不重复的字母，区分大小写,比如a，A是算两个字符 12345678910111213141516171819202122public class HashSetDemo2 &#123; public static void main(String[] args) &#123; String s; System.out.println(&quot;请输入一个字符串：&quot;); Scanner scanner = new Scanner(System.in); s=scanner.nextLine(); //创建HashSet集合 HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); //将字符串拆分成一个个单个字符 char[] chars = s.toCharArray(); for(char ch:chars)&#123; //判断是否是字母 if((ch&gt;=&#x27;a&#x27;&amp;&amp;ch&lt;=&#x27;z&#x27;)||(ch&gt;=&#x27;A&#x27;&amp;&amp;ch&lt;=&#x27;Z&#x27;))&#123; set.add(ch); &#125; &#125; System.out.println(&quot;在该字符串中总共有&quot;+set.size()+&quot;个不重复的字母。&quot;); &#125;&#125; ArrayList中使用contains方法判断是否有重复元素自定义类型Person是Object类的子类，所以Person具备equals方法，而contains方法会调用equals方法，依次与集合当中已经存在的Person对象比较。 当Person类没有重写equals方法时，直接使用Object类继承过来的equals方法，而该方法比较的是对象的地址值。当Person类重写equals方法后，就可以将比较规则由比较地址值改为比较属性值。 下面代码是没有重写equals的： 123456789101112131415public class ArrayList_contains &#123; public static void main(String[] args) &#123; ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); Person jack = new Person(&quot;Jack&quot;, &quot;18&quot;); Person rose = new Person(&quot;Rose&quot;, &quot;22&quot;); Person p = new Person(&quot;Jack&quot;,&quot;18&quot;); list.add(jack); list.add(rose); //这里没有重写equals方法 所以比较的是地址值 因此返回的是False 若重写equals方法比较的是name和age的成员变量则返回true System.out.println(list.contains(p)); &#125;&#125; 下面代码是Person类中重写equals方法： 12345678@Override public boolean equals(Object obj) &#123; Person p=(Person)obj; if(p.getName()==getName()&amp;&amp;p.getAge()==getAge())&#123; return true; &#125; return false; &#125; 重写之后在运行上面代码会发现返回的结果是true。 HashSet判断元素唯一性准则Set集合不能添加重复元素，那其添加方法在添加是判断是否有重复元素，那其判断规则是怎么样的呢？？？ HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法返回的结果。 规则如下： 把对象加入到HashSet时，它会先使用对象的hashCode值来判断对象加入的位置； 如果此位置上没有其他对象存在，则判断元素不同，可存入新对象。 如果此位置有对象存在，先判断新元素与集合内已经有的旧元素的HashCode值：如果不同，判断为是不同的对象，可存入新对象；如果相同，在判断equals比较结果，返回true相同，则不可存入新对象；返回是的false则仍然不同，即可存入新对象。 所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的地址值，如果想通过内容比较元素是否相同，则需要重写该类的hashCode与equals方法。 hashCode方法重写规则： 将对象的各个属性值的hashCode相加即是整个对象的HashCode值。 如果是基本类型，类似int，则直接返回int值就是该属性的hash值； 如果是引用类型，类似String，就调用该成员变量的hashCode方法返回该成员变量的hash值。 这样可以根据对象的内容返回hashCode值，从而可以根据hashCode判断元素是否唯一。但是由于一些“碰巧的”情况下，可能出现内容不同但hashCode相同的情况，为了避免这些情况，我们要加入一些干扰系数。可是加入干扰系数后，仍会出现一些“碰巧”的情况，所以我们还要进行equals的二次判断。 重写hashCode方法代码如下： 1234567@Overridepublic int hashCode() &#123; int thisHashCode thisHashCode+=name.hashCode()*17; thisHashCode+=age.hashCode return thisHashCo&#125; Java集合框架之总结&amp;体系图单列集合体系图 Collection：所有单列集合的直接或间接接口，其指定了所有集合应该具备的基本功能。List：元素可重复，有序，带索引。Set：元素不可重复，无序，没有索引。ArrayList：底层是数组结构，ArrayList的出现代替了Vector，增删慢，查看快。LinkedList：底层是链表结构，同事对元素的增删操作效率高。HashSet：底层是哈希表结构。在不重复的基础上无序。LinkedHashSet：底层是哈希表结构结合链表结构，在不重复的基础上可预测迭代顺序。 集合的常见使用在设计集合的使用时，经常定义对应的接口类型。在使用时，通过多态的方式给接口变量赋值，用于提高程序扩展性。 如：定义方法public void method(List list){}，在调用方法是依据需求，传入ArrayList或LinkedList的对象。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础 集合 HashCode","slug":"Java基础-集合-HashCode","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88-HashCode/"}]},{"title":"Java常用API","slug":"Java常用API","date":"2021-02-27T10:56:53.000Z","updated":"2021-02-28T13:31:51.550Z","comments":true,"path":"2021/02/27/Java常用API/","link":"","permalink":"http://example.com/2021/02/27/Java%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"Java常用APIDate类构造方法： public Date(); public Date(long date); 参数是从1970年01月01日零分以来的毫秒数 普通方法： public long getTime(); public void setTime(long time); DataFormat类DateFormat是日期/时间格式化子类的抽象类，他以与语言无关的方式格式化病解析日期或时间 日期/时间格式化子类（如SimpleDateFormat类）允许进行格式化，解析和标准化。 下面代码实例完成了日期的格式化和解析： 12345678910111213141516171819202122public class DateFormatDemo &#123; public static void main(String[] args) &#123; //日期对象转化为日期字符串 String rule=&quot;yyyy年MM月dd日 HH:mm:ss&quot;; DateFormat format=new SimpleDateFormat(rule); Date date = new Date(); String StrDate=format.format(date); System.out.println(StrDate); //日期字符串转化为日期对象 try &#123; Date parseDate = format.parse(StrDate); System.out.println(parseDate); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Calendar类public static Calendar getInstance(); 获取日历类的子类对象 public int get(int field); 获取时间字段值,可以获取日历的年月日 值得注意的是，这里获取的月是从0月开始的，按照中国人的习惯应该加一 public final void set(int year,int month,int date); 这里月份按照我们的习惯应该在相应的月份减一 public final Date getTime(); 获取该日历对象转成日期对象 代码实例： 123456789101112131415161718192021222324public class CalendarDemo &#123; public static void main(String[] args) &#123; Calendar rightNow = Calendar.getInstance(); System.out.println(rightNow); //Calendar转为Date对象 Date time=rightNow.getTime(); System.out.println(time); //获取属性值 int year=rightNow.get(Calendar.YEAR); System.out.println(&quot;年份：&quot;+year);; int month=rightNow.get(Calendar.MONTH)+1; //这里月份是从0开始的 所以需要加上 1 System.out.println(&quot;月份：&quot;+month); int day=rightNow.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;日：&quot;+day); //设置年月日 rightNow.set(2021,2-1,27); //2021年2月27日 System.out.println(rightNow); &#125;&#125; Math类public static int abs(int a); 返回参数a的绝对值 public static double ceil(double a) 返回大于等于a的最小整数 返回该整数的小数形式 public static double floor(double a) 返回小于等于a的最大整数 public static long round(double a) 对参数a四舍五入，返回四舍五入后的值 public static double pow(double a,double b) 求a的b次幂 返回double形式 System类public static void exit(int status) 操作系统终止该Java程序 0代表正常结束 public static void gc() 暗示Java虚拟机回收不适用的垃圾 public static String getProperty(String key); 获取关于Java的系统属性，如Java版本，Java的vendor，操作系统版本等等。 “os.name” 获取系统的名称 “os.arch” 获取操作系统的架构 “java.home” 获取JRE的目录 “user.dir” 获取当前的工作目录 “user.home” 获取用户的主目录 12345678910111213public class SystemDemo &#123; public static void main(String[] args) &#123; System.out.println(System.getProperty(&quot;os.name&quot;)); System.out.println(System.getProperty(&quot;os.arch&quot;)); System.out.println(System.getProperty(&quot;os.version&quot;)); System.out.println(System.getProperty(&quot;user.home&quot;)); System.out.println(System.getProperty(&quot;user.dir&quot;)); System.out.println(System.getProperty(&quot;java.home&quot;)); System.exit(0); System.out.println(&quot;后面的代码&quot;); //这里不会被执行 &#125;&#125; 运行结果： Windows 10amd6410.0C:\\Users\\LENOVOE:\\Java ProD:\\Environment\\Java\\jdk1.8.0_281\\jre 正则表达式如果需要更加详细的了解正则表达式可以阅读这篇文章https://www.cnblogs.com/xyou/p/7427779.html 正则表达式是一个强大的字符串处理工具，可以对字符串进行查找，提取，分割，替换等操作，是一种可以用于模式匹配和替换的规范。正则表达式用以查找文字主体时待匹配的一个或多个字符串。 String类里也提供了如下几个特殊的方法： boolean matches(String regex) 判断该字符串是否匹配指定的正则表达式 String replaceAll(String regex,String replacement) 将该字符串中所有匹配regex的子串替换成replacement String replaceFirst(String regex,String replacement) 将该字符串中第一个匹配regex的子串替换成replacement String[] split(String regexg) 以regex作为分隔符，把该字符串分割成多个子串 上面这些特殊的方法都依赖与Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。 正则表达式支持的字符创建正则表达式就是创建一个特殊的字符串。 正则表达式所支持的合法字符如下表所示。 字符 解释 X 字符x(x可以是任何合法的字符) \\0mnn 八进制0mnn所表示的字符 \\xhh 十六进制值0x所表示的字符 \\uhhhh 十六进制值0xhhhh所表示的Unicode字符 \\t 制表符(“\\u0009”) \\n 换行符(“u000A”) \\r 回车符(“\\u000D”) \\f 换页符(“\\u000C”) \\a 报警符(“\\u0007”) \\e Escape符(“\\u001B”) \\cx x对应的控制符。例如，\\cM匹配Ctrl-M。x值必须为AZ或az之一 除上面符号外，正则表达式中有一些特殊字符，这些特殊字符在正则表达式中有特殊的用途，比如前面的反斜杠\\。如果需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面加上反斜杠\\。 正则表达式中的特殊字符如下表所示。 特殊字符 说明 $ 匹配一行的结尾。要匹配$自身，要使用$ ^ 匹配一行的开头。要匹配^字符自身，要使用^，下面特殊字符都是如此要匹配自身需要在前面加上反斜杠 () 标记子表达式的开始和结束 [] 用于确定中括号表达式的开始和结束位置 {} 用于表示前面子表达式的出现频度 * 指定前面子表达式可以出现零次或多次 + 指定前面子表达式可以出现一次或多次 ? 指定前面子表达式可以出现零次或一次 . 匹配出换行符\\n以外的任意的单个字符 \\ 用于转义下一个字符，或指定八进制，十六进制 | 指定两项之间任选一项 下面是几个正则表达式的例子： “\\u0041\\\\\\\\“ 匹配 A\\ “\\u0061\\t” 匹配 a&lt;制表符&gt; “\\\\?\\\\[“ 匹配 ?[ 注意：为什么第一个正则表达式中有那么多反斜杠？ 这是因为Java字符串中反斜杠本身需要转义，因此两个反斜杠相当于一个 上面的正则表达式依然只能匹配单个字符，这是因为还未在正则表达式中使用“通配符”，通配符是可以匹配多个字符的特殊符号。正则表达式中的通配符远远超出通配符的功能，他被称为预定义字符，正则表达式支持如下表所示的预定义字符。 预定义字符 说明 . 可以匹配任何字符 \\d 匹配0~9的所有数字 \\D 匹配非数字 \\s 匹配所有的空白字符，包括空格，制表符，回车符，换页符，换行符等 \\S 匹配所有的非空白字符 \\w 匹配所有的单词字符，包括0~9所有数字，26个英文字母和下划线 \\W 匹配所有的非单词字符 上面的七个预定义字符其实非常容易记忆，其中： d是digit的意思，代表数字 s是space的意思，代表空白 w是word的意思，代表单词 d,s,w的大写形式恰好匹配与之相反的字符 有了上面的预定义字符后，接下来就可以创建强大的正则表达式了。例如： c\\\\wt 可以匹配cat,cbt,cct,c0t,c1t等等一批字符 \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d 可以匹配如 nnn-nnn-nnnn形式的电话号码 n是0~9的数字 在一些特殊情况下，例如，若只想匹配 a~f 的字母，或者匹配除 ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有如下表所示的几种形式。 方括号表达式 说明 表示枚举 例如[abc]表示a,b,c其中任意一个字符；[gz]表示其中任意一个字符 表示范围：- 例如[a-f]表示a~f范围内的任意字符；[\\\\u0041-\\\\u0056]表示十六进制字符\\u0041到\\u0056范围内的任意字符 表示就否：^ 例如[^abc]表示非a,b,c的任意字符；[^a-f]表示不是a~f范围内的任意字符 表示‘与’运算：&amp;&amp; 例如[a-z&amp;&amp;[def]]是a~z和[def]的交集，表示d,e,f中任意一个字符 表示‘并’运算 并运算与前面的枚举类似。例如[a-d[m-p]]表示[a-dm-p] 正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。 除此之外，Java 正则表达式还支持如下表所示的几个边界匹配符。 边界匹配符 说明 ^ 行的开头 $ 行的结尾 \\b 单词的边界 \\B 非单词的边界 \\A 输入的开头 \\G 前一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符 \\z 输入的结尾 前面例子中需要建立一个匹配 000-000-0000 形式的电话号码时，使用了 \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。 Greedy（贪婪模式）：**数量表示符默认采用贪婪模式**，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。 Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。 三种模式的数量表示符如下表所示。 贪婪模式 勉强模式 占用模式 说明 X? X?? X?+ X表达式出现零次或一次 X* X*? X*+ X表达式出现零次或多次 X+ X+? X++ X表达式出现一次或多次 X{n} X{n}? X{n}+ X表达式出现n次 X{n,} X{n,}? X{n,}+ X表达式最少出现n次 X{n,m} X{n,m}? X{n,m}+ X表达式最少出现n次最多出现m次 下面的代码是关于贪婪模式和勉强模式的对比： 123456789101112public class RegexDemo &#123; public static void main(String[] args) &#123; String str=&quot;hello,world!&quot;; //贪婪模式下的正则表达式 System.out.println(str.replaceFirst(&quot;\\\\w*&quot;,&quot;#&quot;)); //输出 #,world! // &quot;\\\\w+&quot; 两个斜杠是因为Java中\\斜杠也需要转义 //勉强模式的正则表达式 System.out.println(str.replaceFirst(&quot;\\\\w*?&quot;,&quot;#&quot;)); //输出 #hello,world! &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaAPI 正则表达式","slug":"JavaAPI-正则表达式","permalink":"http://example.com/tags/JavaAPI-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"JavaIO","slug":"JavaIO","date":"2021-02-25T06:37:12.000Z","updated":"2021-02-26T10:47:50.368Z","comments":true,"path":"2021/02/25/JavaIO/","link":"","permalink":"http://example.com/2021/02/25/JavaIO/","excerpt":"","text":"JavaIOFileWriter构造方法： FileWriter(String fileName) 需要传入一个文件路径 成员方法： void write(String str) 向指定文件写入字符str void write(String str,int index,int len); 写入一个字符串中的一部分数据 void write(int ch); 写入一个字符串数据，这里参数是int的好处是既可以写入一个char烈性的数据也可以写入char对应的int类型的值。如‘a’对应97 void write(char[] chs) 写入一个字符数组数据 void write(char[] chs,int index,int len) 写入一个字符数组的一部分数据 void flush() 清空缓冲区数据 使其全部写入到指定文件 因此一般在关闭流之前需要调用该方法 void close() 关闭流释放系统底层资源 FileWriter写入换行以及向文本末尾追加写入换行： \\n可以实现换行，但是windows系统自带的记事本打开并没有换行，因为Windows识别换行不是\\n，而是\\r\\n。 windows: \\r\\n linux: \\n mac: \\r 实现数据的追加写入： FileWriter(String fileName,boolean append); FileWriter默认是覆盖原文的，若需要在原文的基础上在追加内容则可以使用FileWriter(fileName,true)方式创建输入流对象 FileReader构造方法： FileReader(String fileName) 成员方法： int read() 读取单个字符 int read(char[] buf) 读取字符，并将字符读入数组buf中 返回的是读取字符的个数 代码实例：1234567891011121314151617181920212223242526272829303132public class FileReaderDemo &#123; public static void main(String[] args) &#123; try &#123; FileReader fr = new FileReader(&quot;a.txt&quot;); int ch; while ((ch=fr.read())!=-1)&#123; //一次读取一个字符 System.out.print((char)ch); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;-------------&quot;); try &#123; FileReader fr=new FileReader(&quot;a.txt&quot;); char[] chs=new char[10]; int len=0; int i=0; while((len=fr.read(chs))!=-1)&#123; //一次读取 i++; System.out.println(&quot;第&quot;+i+&quot;次读取&quot;+len+&quot;个字符&quot;); System.out.print(new String(chs,0,len)); System.out.println(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： hello world!第1次读取10个字符hello worl第2次读取4个字符d! 缓冲流 BufferedWriter: 将文本写入字符输出流，缓冲各个字符，从而提供单个字符，数组和字符串的高效写入。 BufferedReader: 从字符输入流读取文本，缓冲各个字符，从而实现字符，数组和行的高效读取。 缓冲流复制文本文件两种方式 使用缓冲流不使用字符数组 使用缓冲流使用字符数组 代码实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BufferedStreamDemo &#123; public static void main(String[] args) &#123; BufferedReader br=null; BufferedWriter bw=null; try &#123; br = new BufferedReader(new FileReader(&quot;a.txt&quot;)); bw = new BufferedWriter(new FileWriter(&quot;copy.txt&quot;)); //不使用数组读写数据 一次读写一个字符// int ch;// while((ch=br.read())!=-1)&#123;// bw.write(ch);// &#125; //使用字符数组读写数据 一次读写一个字符数组 char[] chs=new char[1024]; int len; while((len=br.read(chs))!=-1)&#123; bw.write(chs,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(br!=null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bw!=null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 缓冲流的特有方法void newLine(); 写一个换行符，这个换行符由系统决定，不同的操作系统newLine()方法使用的换行符不同，我们不在需要知道系统的换行符是什么。 String readLine(); 一次读取一行数据，但是不读取换行符 12345678910111213141516171819202122232425public class BufferedStreamDemo2 &#123; public static void main(String[] args) &#123; try &#123; BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;)); for(int i=0;i&lt;3;i++)&#123; bw.write(&quot;Hello World!&quot;); //bw.write(&quot;\\r\\n&quot;); 使用newLine方法我们不需要知道某个系统的换行符是什么 bw.newLine(); &#125; bw.flush(); bw.close(); BufferedReader br=new BufferedReader(new FileReader(&quot;a.txt&quot;)); String line; while((line= br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaIO java","slug":"JavaIO-java","permalink":"http://example.com/tags/JavaIO-java/"}]},{"title":"Java判断两字符串是否相等","slug":"Java判断两字符串是否相等","date":"2021-02-23T02:31:24.000Z","updated":"2021-02-24T13:18:51.295Z","comments":true,"path":"2021/02/23/Java判断两字符串是否相等/","link":"","permalink":"http://example.com/2021/02/23/Java%E5%88%A4%E6%96%AD%E4%B8%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/","excerpt":"","text":"判断两字符串是否相等字符串常量池字符串的分类和其他对象的分配一样，需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。 Java中常量池，实际分类两种形态：静态常量池和运行时常量池。 静态常量池：即 *.class文件中的常量池，class文件中的常量池不仅仅包含字符串（数字）字面量，还包括类，方法的信息，占用class文件的绝大空间。 运行时常量池：JVM虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，而我们常说的常量池，就是指方法区中的运行时常量池。 来看看下面的程序及结果： 12345678String s1 &#x3D; new String(&quot;hello&quot;);String s2 &#x3D; new String(&quot;hello&quot;);String s3&#x3D;&quot;hello&quot;;String s4&#x3D;&quot;hello&quot;;System.out.println(s1&#x3D;&#x3D;s2);System.out.println(s1&#x3D;&#x3D;s3);System.out.println(s3&#x3D;&#x3D;s4); falsefalsetrue 对于引用型数据，==比较的是引用型数据的地址值是否相同。上面程序new关键字一定会产生一个对象。上述程序中使用new关键字产生了两个对象（s1,s2分别指向这两个对象），保存在堆中。但在Java中不会存在完全一模一样的字符串对象，故堆中的s1,s2应该是引用字符串常量池中的“hello”。因此s1!=s2。而对于s1和s3，s1引用的是字符串常量池中“hello”的地址，s2引用的是堆中new出来的对象的地址，所以s1!=s3。s3和s4都是引用字符串常量池中“hello”的地址。 内存模型如下图： 总结s1,s2,s3,”hello”是不同的对象。String s1=new String(“hello”),虽然s1的内容是创建在堆中，但是他的内部value还是指向JVM常量池的“hello”的value。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java Java基础","slug":"Java-Java基础","permalink":"http://example.com/tags/Java-Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java对象创建过程详解","slug":"Java对象创建过程详解","date":"2021-02-22T06:59:21.000Z","updated":"2021-02-24T13:19:07.574Z","comments":true,"path":"2021/02/22/Java对象创建过程详解/","link":"","permalink":"http://example.com/2021/02/22/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"概述Java对象创建分为两个过程：声明对象和创建对象实体。类信息，对象引用，对象实体均在内存的不同区域。 内存结构每一个Java引用程序均会唯一的对应一个JVM实例，而这个JVM实例将会完成对象内存分配，程序运行，垃圾回收等工作。JVM将其内存大致分类三个区域：方法区，栈区，堆区。 方法区：是JVM在装载类文件时，用于存储类的所有描述信息的，这些信息主要包括，类的基本信息（访问修饰符，类名），字段信息（修饰符，类型，字段名），方法信息（修饰符，返回值类型，方法名，参数列表类型，异常，方法体字节码等等），常量池，静态区，classloader以及class引用。 栈区：存放局部变量，基本数据类型和对象引用类型 堆区：用于存放new产生对象的实体，每一个对象实体均会有自己的内存地址，一旦这个内存地址不被任何栈区对象引用，就会成为垃圾，随时会被GC回收。 成员变量和局部变量 成员变量：在类中方法外，存储在堆内存中，随着对象的存在而存在，随着对象的消失而消失。有默认的初始化值。 局部变量：在方法体中，存储在栈内存中，随着方法的调用而存在，随着方法的调用完毕而消失。没有默认的初始化值，所以必须先定义，赋值后才可以被使用。 对象创建过程1234567891011121314151617181920212223242526272829303132333435363738package combendy;public class Demo_04 &#123; static&#123; System.out.println(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; Inner inner1 = new Inner(); Inner inner2 = new Inner(30); System.out.println((inner1.ii==inner2.ii)+&quot; &quot;+Inner.ii); System.out.println(inner1.str==inner2.str); &#125; static class Inner&#123; private String str=&quot;hello&quot;; //成员变量 存储在堆内存中 private int i; private static int ii=10; //静态变量，存储在方法区中（这也是为什么静态变量能在多个对象共享的原因） private static int iii;// 静态代码块 static&#123; System.out.println(&quot;ii=&quot;+ii+&quot;,iii=&quot;+iii); &#125;// &#123; System.out.println(&quot;str=&quot;+str+&quot;,i=&quot;+i+&quot;,ii=&quot;+ii+&quot;,iii=&quot;+iii); &#125; public Inner()&#123; ii=20; System.out.println(&quot;non-arguments&quot;); &#125; public Inner(int i)&#123; this.i=i; System.out.println(&quot;one-arguments&quot;); &#125; &#125;&#125; 运行结果 Helloii=10,iii=0str=hello,i=0,ii=10,iii=0non-argumentsstr=hello,i=0,ii=20,iii=0one-argumentstrue 20true 步骤 将JVM加载进内存中 JVM首先检查public类是否存在，存在就会将他加载进内存方法去中，否者抛出异常，结束进程 对类中静态字段进行初始化（若无显示初始化，就会被赋值为默认值），接着执行静态代码块 在栈中创建局部变量，堆中创建对象实体，为堆对象实体的成员变量（非静态）初始化，对于静态字段只需要从方法区的静态区中引用其值即可，执行构造代码块，接着执行构造函数（这里调用顺序会一直上溯到Object类，每一个构造方法的第一行为super()语句），最后将对象实体堆地址赋值给栈中引用变量。 要注意的是，实例字段包括自身定义的和从父类继承下来的（即使父类的实例字段被子类覆盖或者被private修饰，都照样为其分配内存） C++中的引用和JAVA的引用作对比，其实他们两个只是“名称”一样，本质并没什么关系，C++中的引用只是给现存变量起了一个别名(引用变量只是一个符号引用而已，编译器并不会给引用分配新的内存)，而JAVA中的引用变量却是真真正正的变量，具有自己的内存空间，只是不同的引用变量可以“指向”同一个对象而已。因此，如果要拿C++和JAVA引用对象的方式相对比，C++中的指针倒和JAVA中的引用如出一辙，毕竟，JAVA中的引用其实就是对指针的封装","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-16T09:52:52.898Z","updated":"2021-02-16T09:52:52.898Z","comments":true,"path":"2021/02/16/hello-world/","link":"","permalink":"http://example.com/2021/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础 JavaIO 字节流","slug":"Java基础-JavaIO-字节流","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-JavaIO-%E5%AD%97%E8%8A%82%E6%B5%81/"},{"name":"Java基础 Map","slug":"Java基础-Map","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-Map/"},{"name":"Java基础 集合 HashCode","slug":"Java基础-集合-HashCode","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88-HashCode/"},{"name":"JavaAPI 正则表达式","slug":"JavaAPI-正则表达式","permalink":"http://example.com/tags/JavaAPI-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"JavaIO java","slug":"JavaIO-java","permalink":"http://example.com/tags/JavaIO-java/"},{"name":"Java Java基础","slug":"Java-Java基础","permalink":"http://example.com/tags/Java-Java%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}