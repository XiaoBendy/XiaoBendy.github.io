{"meta":{"title":"XiaoBendy","subtitle":"","description":"","author":"XiaoBendy","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-02-21T05:03:23.000Z","updated":"2021-02-21T05:06:17.482Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-21T04:43:44.000Z","updated":"2021-02-22T11:42:04.102Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java集合","slug":"Java集合","date":"2021-03-03T14:37:30.000Z","updated":"2021-03-04T06:42:45.713Z","comments":true,"path":"2021/03/03/Java集合/","link":"","permalink":"http://example.com/2021/03/03/Java%E9%9B%86%E5%90%88/","excerpt":"","text":"LinkedList类LinkedList与ArrayList不同，LinkedList是方便添加或删除的List。实际开发中对一个集合元素的添加和删除经常会涉及到首尾的操作。 LinkedList的特点是添加和删除块，但是查询慢。这是因为LinkedList是链表在添加和删除元素时，只需要修改上一个节点记录的地址值即可；而对于查询则需要遍历到要查询的元素为止。 ArrayList的特点是查询快，添加和删除慢。查询快是由于数组的索引支持，所以可以通过直接计算出元素的地址值，因此可以直接通过元素的地址值获取指定的元素；添加和删除慢是因为ArrayList在添加和删除元素时，在底层会先创建一个新数组，先需要堆数组原有的数组进行拷贝，其次在末尾进行添加或者删除元素。 LinkedList提供了大量首尾操作： public void addFirst(E e); public void addLast(E e); public E getFirst(); public E getLast(); 代码实例如下： 123456789101112131415161718192021222324252627282930313233public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list=new LinkedList&lt;String&gt;(); //添加元素 list.add(&quot;Jack&quot;); list.add(&quot;Rose&quot;); list.add(&quot;Trump&quot;); //获取元素 String name=list.get(1); System.out.println(&quot;第二个元素：&quot;+name); //返回集合的迭代器 Iterator&lt;String&gt; it=list.iterator(); //利用迭代器便利 while(it.hasNext())&#123; String thisName=it.next(); System.out.println(thisName); &#125; System.out.println(&quot;------------&quot;); //使用增强for循环便利 for(String thisName:list)&#123; System.out.println(thisName); &#125; System.out.println(list); //删除 list.remove(); //默认删除第一个元素 也可以通过索引删除指定元素或者删除首尾元素 System.out.println(list); &#125;&#125; 运行结果： 12345678910第二个元素：RoseJackRoseTrump------------JackRoseTrump[Jack, Rose, Trump][Rose, Trump] LinkedList可支持栈结构当然Java也提供专门用于栈结构的类Stack LinkedList对于栈结构提供了如下的方法： push 压栈 pop 弹栈 peek 查询出即将要出栈的元素（栈顶元素），检查有没有要弹出的元素,当栈为空时就返回空值。 代码实例： 1234567891011121314151617181920212223public class StackDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;(); stack.push(&quot;Jack&quot;); stack.push(&quot;Rose&quot;); stack.push(&quot;Lisa&quot;); System.out.println(stack); //获取一个元素 此时，由于是栈结构 所以获取的是最后压栈的元素 String popName=stack.pop(); //这里获取的是Lisa元素 System.out.println(popName); System.out.println(stack); String peekName=stack.peek(); System.out.println(peekName); //peek查看元素不会减少元素 System.out.println(stack); &#125;&#125; 运行结果： 12345[Lisa, Rose, Jack]Lisa[Rose, Jack]Rose[Rose, Jack] 注意这里输出栈时，是从栈顶到栈底依次输出 LinkedList可支持队列结构LinkedList为支持队列元素提供了如下的方法： offer 加入队列 poll 离开队列 peek 查询出即将要离开队列的元素（即队首元素），可检查有没有要离开队列的元素,当队列为空时返回空值null 代码实例： 12345678910111213141516171819202122232425262728public class QueueDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(&quot;Jack&quot;); queue.offer(&quot;Rose&quot;); queue.offer(&quot;Lisa&quot;); System.out.println(queue); //获取队首元素 String pollName=queue.poll(); System.out.println(pollName); System.out.println(queue); String peekName=queue.peek(); System.out.println(peekName); System.out.println(queue); //清空队列 queue.remove(); queue.remove(); //检查是否还有要离开的元素 String name=queue.peek(); System.out.println(name); //队列为空时 peek()返回的是空值null &#125;&#125; 运行结果： 123456[Jack, Rose, Lisa]Jack[Rose, Lisa]Rose[Rose, Lisa]null HashSet类HashSet是Set接口的子类，不包括重复相同的元素，*并且是无序的**，且提供索引，所以不能通过索引获取元素，只能通过迭代器访问数据*** HashSet下还有子类LinkedHashSet,是可预测迭代顺序的Set的集合。 代码实例： 1234567891011121314151617181920212223public class HashSetDemo &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;Jack&quot;); set.add(&quot;Lisa&quot;); set.add(&quot;Rose&quot;); set.add(&quot;Rose&quot;); System.out.println(set); //输出是无序的 //获取元素，只能迭代器 Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; String name = it.next(); System.out.println(name); &#125; System.out.println(&quot;============&quot;); //使用增强for遍历set集合 for(String name:set)&#123; System.out.println(name); &#125; &#125;&#125; 运行结果： 12345678[Rose, Jack, Lisa]RoseJackLisa============RoseJackLisa 注意这里输出结果是无序的，还要记住不能通过索引来访问只能使用迭代器来访问数据 HashSet的简单应用：使用HashSet求一个字符串中一共有几个不重复的字母，区分大小写,比如a，A是算两个字符 12345678910111213141516171819202122public class HashSetDemo2 &#123; public static void main(String[] args) &#123; String s; System.out.println(&quot;请输入一个字符串：&quot;); Scanner scanner = new Scanner(System.in); s=scanner.nextLine(); //创建HashSet集合 HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); //将字符串拆分成一个个单个字符 char[] chars = s.toCharArray(); for(char ch:chars)&#123; //判断是否是字母 if((ch&gt;=&#x27;a&#x27;&amp;&amp;ch&lt;=&#x27;z&#x27;)||(ch&gt;=&#x27;A&#x27;&amp;&amp;ch&lt;=&#x27;Z&#x27;))&#123; set.add(ch); &#125; &#125; System.out.println(&quot;在该字符串中总共有&quot;+set.size()+&quot;个不重复的字母。&quot;); &#125;&#125; ArrayList中使用contains方法判断是否有重复元素自定义类型Person是Object类的子类，所以Person具备equals方法，而contains方法会调用equals方法，依次与集合当中已经存在的Person对象比较。 当Person类没有重写equals方法时，直接使用Object类继承过来的equals方法，而该方法比较的是对象的地址值。当Person类重写equals方法后，就可以将比较规则由比较地址值改为比较属性值。 下面代码是没有重写equals的： 123456789101112131415public class ArrayList_contains &#123; public static void main(String[] args) &#123; ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); Person jack = new Person(&quot;Jack&quot;, &quot;18&quot;); Person rose = new Person(&quot;Rose&quot;, &quot;22&quot;); Person p = new Person(&quot;Jack&quot;,&quot;18&quot;); list.add(jack); list.add(rose); //这里没有重写equals方法 所以比较的是地址值 因此返回的是False 若重写equals方法比较的是name和age的成员变量则返回true System.out.println(list.contains(p)); &#125;&#125; 下面代码是Person类中重写equals方法： 12345678@Override public boolean equals(Object obj) &#123; Person p=(Person)obj; if(p.getName()==getName()&amp;&amp;p.getAge()==getAge())&#123; return true; &#125; return false; &#125; 重写之后在运行上面代码会发现返回的结果是true。 HashSet判断元素唯一性准则Set集合不能添加重复元素，那其添加方法在添加是判断是否有重复元素，那其判断规则是怎么样的呢？？？ HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法返回的结果。 规则如下： 把对象加入到HashSet时，它会先使用对象的hashCode值来判断对象加入的位置； 如果此位置上没有其他对象存在，则判断元素不同，可存入新对象。 如果此位置有对象存在，先判断新元素与集合内已经有的旧元素的HashCode值：如果不同，判断为是不同的对象，可存入新对象；如果相同，在判断equals比较结果，返回true相同，则不可存入新对象；返回是的false则仍然不同，即可存入新对象。 所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的地址值，如果想通过内容比较元素是否相同，则需要重写该类的hashCode与equals方法。 hashCode方法重写规则： 将对象的各个属性值的hashCode相加即是整个对象的HashCode值。 如果是基本类型，类似int，则直接返回int值就是该属性的hash值； 如果是引用类型，类似String，就调用该成员变量的hashCode方法返回该成员变量的hash值。 这样可以根据对象的内容返回hashCode值，从而可以根据hashCode判断元素是否唯一。但是由于一些“碰巧的”情况下，可能出现内容不同但hashCode相同的情况，为了避免这些情况，我们要加入一些干扰系数。可是加入干扰系数后，仍会出现一些“碰巧”的情况，所以我们还要进行equals的二次判断。 重写hashCode方法代码如下： 1234567@Overridepublic int hashCode() &#123; int thisHashCode thisHashCode+=name.hashCode()*17; thisHashCode+=age.hashCode return thisHashCo&#125; Java集合框架之总结&amp;体系图单列集合体系图 Collection：所有单列集合的直接或间接接口，其指定了所有集合应该具备的基本功能。List：元素可重复，有序，带索引。Set：元素不可重复，无序，没有索引。ArrayList：底层是数组结构，ArrayList的出现代替了Vector，增删慢，查看快。LinkedList：底层是链表结构，同事对元素的增删操作效率高。HashSet：底层是哈希表结构。在不重复的基础上无序。LinkedHashSet：底层是哈希表结构结合链表结构，在不重复的基础上可预测迭代顺序。 集合的常见使用在设计集合的使用时，经常定义对应的接口类型。在使用时，通过多态的方式给接口变量赋值，用于提高程序扩展性。 如：定义方法public void method(List list){}，在调用方法是依据需求，传入ArrayList或LinkedList的对象。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础 集合 HashCode","slug":"Java基础-集合-HashCode","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88-HashCode/"}]},{"title":"Java常用API","slug":"Java常用API","date":"2021-02-27T10:56:53.000Z","updated":"2021-02-28T13:31:51.550Z","comments":true,"path":"2021/02/27/Java常用API/","link":"","permalink":"http://example.com/2021/02/27/Java%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"Java常用APIDate类构造方法： public Date(); public Date(long date); 参数是从1970年01月01日零分以来的毫秒数 普通方法： public long getTime(); public void setTime(long time); DataFormat类DateFormat是日期/时间格式化子类的抽象类，他以与语言无关的方式格式化病解析日期或时间 日期/时间格式化子类（如SimpleDateFormat类）允许进行格式化，解析和标准化。 下面代码实例完成了日期的格式化和解析： 12345678910111213141516171819202122public class DateFormatDemo &#123; public static void main(String[] args) &#123; //日期对象转化为日期字符串 String rule=&quot;yyyy年MM月dd日 HH:mm:ss&quot;; DateFormat format=new SimpleDateFormat(rule); Date date = new Date(); String StrDate=format.format(date); System.out.println(StrDate); //日期字符串转化为日期对象 try &#123; Date parseDate = format.parse(StrDate); System.out.println(parseDate); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Calendar类public static Calendar getInstance(); 获取日历类的子类对象 public int get(int field); 获取时间字段值,可以获取日历的年月日 值得注意的是，这里获取的月是从0月开始的，按照中国人的习惯应该加一 public final void set(int year,int month,int date); 这里月份按照我们的习惯应该在相应的月份减一 public final Date getTime(); 获取该日历对象转成日期对象 代码实例： 123456789101112131415161718192021222324public class CalendarDemo &#123; public static void main(String[] args) &#123; Calendar rightNow = Calendar.getInstance(); System.out.println(rightNow); //Calendar转为Date对象 Date time=rightNow.getTime(); System.out.println(time); //获取属性值 int year=rightNow.get(Calendar.YEAR); System.out.println(&quot;年份：&quot;+year);; int month=rightNow.get(Calendar.MONTH)+1; //这里月份是从0开始的 所以需要加上 1 System.out.println(&quot;月份：&quot;+month); int day=rightNow.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;日：&quot;+day); //设置年月日 rightNow.set(2021,2-1,27); //2021年2月27日 System.out.println(rightNow); &#125;&#125; Math类public static int abs(int a); 返回参数a的绝对值 public static double ceil(double a) 返回大于等于a的最小整数 返回该整数的小数形式 public static double floor(double a) 返回小于等于a的最大整数 public static long round(double a) 对参数a四舍五入，返回四舍五入后的值 public static double pow(double a,double b) 求a的b次幂 返回double形式 System类public static void exit(int status) 操作系统终止该Java程序 0代表正常结束 public static void gc() 暗示Java虚拟机回收不适用的垃圾 public static String getProperty(String key); 获取关于Java的系统属性，如Java版本，Java的vendor，操作系统版本等等。 “os.name” 获取系统的名称 “os.arch” 获取操作系统的架构 “java.home” 获取JRE的目录 “user.dir” 获取当前的工作目录 “user.home” 获取用户的主目录 12345678910111213public class SystemDemo &#123; public static void main(String[] args) &#123; System.out.println(System.getProperty(&quot;os.name&quot;)); System.out.println(System.getProperty(&quot;os.arch&quot;)); System.out.println(System.getProperty(&quot;os.version&quot;)); System.out.println(System.getProperty(&quot;user.home&quot;)); System.out.println(System.getProperty(&quot;user.dir&quot;)); System.out.println(System.getProperty(&quot;java.home&quot;)); System.exit(0); System.out.println(&quot;后面的代码&quot;); //这里不会被执行 &#125;&#125; 运行结果： Windows 10amd6410.0C:\\Users\\LENOVOE:\\Java ProD:\\Environment\\Java\\jdk1.8.0_281\\jre 正则表达式如果需要更加详细的了解正则表达式可以阅读这篇文章https://www.cnblogs.com/xyou/p/7427779.html 正则表达式是一个强大的字符串处理工具，可以对字符串进行查找，提取，分割，替换等操作，是一种可以用于模式匹配和替换的规范。正则表达式用以查找文字主体时待匹配的一个或多个字符串。 String类里也提供了如下几个特殊的方法： boolean matches(String regex) 判断该字符串是否匹配指定的正则表达式 String replaceAll(String regex,String replacement) 将该字符串中所有匹配regex的子串替换成replacement String replaceFirst(String regex,String replacement) 将该字符串中第一个匹配regex的子串替换成replacement String[] split(String regexg) 以regex作为分隔符，把该字符串分割成多个子串 上面这些特殊的方法都依赖与Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。 正则表达式支持的字符创建正则表达式就是创建一个特殊的字符串。 正则表达式所支持的合法字符如下表所示。 字符 解释 X 字符x(x可以是任何合法的字符) \\0mnn 八进制0mnn所表示的字符 \\xhh 十六进制值0x所表示的字符 \\uhhhh 十六进制值0xhhhh所表示的Unicode字符 \\t 制表符(“\\u0009”) \\n 换行符(“u000A”) \\r 回车符(“\\u000D”) \\f 换页符(“\\u000C”) \\a 报警符(“\\u0007”) \\e Escape符(“\\u001B”) \\cx x对应的控制符。例如，\\cM匹配Ctrl-M。x值必须为AZ或az之一 除上面符号外，正则表达式中有一些特殊字符，这些特殊字符在正则表达式中有特殊的用途，比如前面的反斜杠\\。如果需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面加上反斜杠\\。 正则表达式中的特殊字符如下表所示。 特殊字符 说明 $ 匹配一行的结尾。要匹配$自身，要使用$ ^ 匹配一行的开头。要匹配^字符自身，要使用^，下面特殊字符都是如此要匹配自身需要在前面加上反斜杠 () 标记子表达式的开始和结束 [] 用于确定中括号表达式的开始和结束位置 {} 用于表示前面子表达式的出现频度 * 指定前面子表达式可以出现零次或多次 + 指定前面子表达式可以出现一次或多次 ? 指定前面子表达式可以出现零次或一次 . 匹配出换行符\\n以外的任意的单个字符 \\ 用于转义下一个字符，或指定八进制，十六进制 | 指定两项之间任选一项 下面是几个正则表达式的例子： “\\u0041\\\\\\\\“ 匹配 A\\ “\\u0061\\t” 匹配 a&lt;制表符&gt; “\\\\?\\\\[“ 匹配 ?[ 注意：为什么第一个正则表达式中有那么多反斜杠？ 这是因为Java字符串中反斜杠本身需要转义，因此两个反斜杠相当于一个 上面的正则表达式依然只能匹配单个字符，这是因为还未在正则表达式中使用“通配符”，通配符是可以匹配多个字符的特殊符号。正则表达式中的通配符远远超出通配符的功能，他被称为预定义字符，正则表达式支持如下表所示的预定义字符。 预定义字符 说明 . 可以匹配任何字符 \\d 匹配0~9的所有数字 \\D 匹配非数字 \\s 匹配所有的空白字符，包括空格，制表符，回车符，换页符，换行符等 \\S 匹配所有的非空白字符 \\w 匹配所有的单词字符，包括0~9所有数字，26个英文字母和下划线 \\W 匹配所有的非单词字符 上面的七个预定义字符其实非常容易记忆，其中： d是digit的意思，代表数字 s是space的意思，代表空白 w是word的意思，代表单词 d,s,w的大写形式恰好匹配与之相反的字符 有了上面的预定义字符后，接下来就可以创建强大的正则表达式了。例如： c\\\\wt 可以匹配cat,cbt,cct,c0t,c1t等等一批字符 \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d 可以匹配如 nnn-nnn-nnnn形式的电话号码 n是0~9的数字 在一些特殊情况下，例如，若只想匹配 a~f 的字母，或者匹配除 ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有如下表所示的几种形式。 方括号表达式 说明 表示枚举 例如[abc]表示a,b,c其中任意一个字符；[gz]表示其中任意一个字符 表示范围：- 例如[a-f]表示a~f范围内的任意字符；[\\\\u0041-\\\\u0056]表示十六进制字符\\u0041到\\u0056范围内的任意字符 表示就否：^ 例如[^abc]表示非a,b,c的任意字符；[^a-f]表示不是a~f范围内的任意字符 表示‘与’运算：&amp;&amp; 例如[a-z&amp;&amp;[def]]是a~z和[def]的交集，表示d,e,f中任意一个字符 表示‘并’运算 并运算与前面的枚举类似。例如[a-d[m-p]]表示[a-dm-p] 正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。 除此之外，Java 正则表达式还支持如下表所示的几个边界匹配符。 边界匹配符 说明 ^ 行的开头 $ 行的结尾 \\b 单词的边界 \\B 非单词的边界 \\A 输入的开头 \\G 前一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符 \\z 输入的结尾 前面例子中需要建立一个匹配 000-000-0000 形式的电话号码时，使用了 \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。 Greedy（贪婪模式）：**数量表示符默认采用贪婪模式**，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。 Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。 三种模式的数量表示符如下表所示。 贪婪模式 勉强模式 占用模式 说明 X? X?? X?+ X表达式出现零次或一次 X* X*? X*+ X表达式出现零次或多次 X+ X+? X++ X表达式出现一次或多次 X{n} X{n}? X{n}+ X表达式出现n次 X{n,} X{n,}? X{n,}+ X表达式最少出现n次 X{n,m} X{n,m}? X{n,m}+ X表达式最少出现n次最多出现m次 下面的代码是关于贪婪模式和勉强模式的对比： 123456789101112public class RegexDemo &#123; public static void main(String[] args) &#123; String str=&quot;hello,world!&quot;; //贪婪模式下的正则表达式 System.out.println(str.replaceFirst(&quot;\\\\w*&quot;,&quot;#&quot;)); //输出 #,world! // &quot;\\\\w+&quot; 两个斜杠是因为Java中\\斜杠也需要转义 //勉强模式的正则表达式 System.out.println(str.replaceFirst(&quot;\\\\w*?&quot;,&quot;#&quot;)); //输出 #hello,world! &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaAPI 正则表达式","slug":"JavaAPI-正则表达式","permalink":"http://example.com/tags/JavaAPI-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"JavaIO","slug":"JavaIO","date":"2021-02-25T06:37:12.000Z","updated":"2021-02-26T10:47:50.368Z","comments":true,"path":"2021/02/25/JavaIO/","link":"","permalink":"http://example.com/2021/02/25/JavaIO/","excerpt":"","text":"JavaIOFileWriter构造方法： FileWriter(String fileName) 需要传入一个文件路径 成员方法： void write(String str) 向指定文件写入字符str void write(String str,int index,int len); 写入一个字符串中的一部分数据 void write(int ch); 写入一个字符串数据，这里参数是int的好处是既可以写入一个char烈性的数据也可以写入char对应的int类型的值。如‘a’对应97 void write(char[] chs) 写入一个字符数组数据 void write(char[] chs,int index,int len) 写入一个字符数组的一部分数据 void flush() 清空缓冲区数据 使其全部写入到指定文件 因此一般在关闭流之前需要调用该方法 void close() 关闭流释放系统底层资源 FileWriter写入换行以及向文本末尾追加写入换行： \\n可以实现换行，但是windows系统自带的记事本打开并没有换行，因为Windows识别换行不是\\n，而是\\r\\n。 windows: \\r\\n linux: \\n mac: \\r 实现数据的追加写入： FileWriter(String fileName,boolean append); FileWriter默认是覆盖原文的，若需要在原文的基础上在追加内容则可以使用FileWriter(fileName,true)方式创建输入流对象 FileReader构造方法： FileReader(String fileName) 成员方法： int read() 读取单个字符 int read(char[] buf) 读取字符，并将字符读入数组buf中 返回的是读取字符的个数 代码实例：1234567891011121314151617181920212223242526272829303132public class FileReaderDemo &#123; public static void main(String[] args) &#123; try &#123; FileReader fr = new FileReader(&quot;a.txt&quot;); int ch; while ((ch=fr.read())!=-1)&#123; //一次读取一个字符 System.out.print((char)ch); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;-------------&quot;); try &#123; FileReader fr=new FileReader(&quot;a.txt&quot;); char[] chs=new char[10]; int len=0; int i=0; while((len=fr.read(chs))!=-1)&#123; //一次读取 i++; System.out.println(&quot;第&quot;+i+&quot;次读取&quot;+len+&quot;个字符&quot;); System.out.print(new String(chs,0,len)); System.out.println(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： hello world!第1次读取10个字符hello worl第2次读取4个字符d! 缓冲流 BufferedWriter: 将文本写入字符输出流，缓冲各个字符，从而提供单个字符，数组和字符串的高效写入。 BufferedReader: 从字符输入流读取文本，缓冲各个字符，从而实现字符，数组和行的高效读取。 缓冲流复制文本文件两种方式 使用缓冲流不使用字符数组 使用缓冲流使用字符数组 代码实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BufferedStreamDemo &#123; public static void main(String[] args) &#123; BufferedReader br=null; BufferedWriter bw=null; try &#123; br = new BufferedReader(new FileReader(&quot;a.txt&quot;)); bw = new BufferedWriter(new FileWriter(&quot;copy.txt&quot;)); //不使用数组读写数据 一次读写一个字符// int ch;// while((ch=br.read())!=-1)&#123;// bw.write(ch);// &#125; //使用字符数组读写数据 一次读写一个字符数组 char[] chs=new char[1024]; int len; while((len=br.read(chs))!=-1)&#123; bw.write(chs,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(br!=null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bw!=null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 缓冲流的特有方法void newLine(); 写一个换行符，这个换行符由系统决定，不同的操作系统newLine()方法使用的换行符不同，我们不在需要知道系统的换行符是什么。 String readLine(); 一次读取一行数据，但是不读取换行符 12345678910111213141516171819202122232425public class BufferedStreamDemo2 &#123; public static void main(String[] args) &#123; try &#123; BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;)); for(int i=0;i&lt;3;i++)&#123; bw.write(&quot;Hello World!&quot;); //bw.write(&quot;\\r\\n&quot;); 使用newLine方法我们不需要知道某个系统的换行符是什么 bw.newLine(); &#125; bw.flush(); bw.close(); BufferedReader br=new BufferedReader(new FileReader(&quot;a.txt&quot;)); String line; while((line= br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaIO java","slug":"JavaIO-java","permalink":"http://example.com/tags/JavaIO-java/"}]},{"title":"Java判断两字符串是否相等","slug":"Java判断两字符串是否相等","date":"2021-02-23T02:31:24.000Z","updated":"2021-02-24T13:18:51.295Z","comments":true,"path":"2021/02/23/Java判断两字符串是否相等/","link":"","permalink":"http://example.com/2021/02/23/Java%E5%88%A4%E6%96%AD%E4%B8%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/","excerpt":"","text":"判断两字符串是否相等字符串常量池字符串的分类和其他对象的分配一样，需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。 Java中常量池，实际分类两种形态：静态常量池和运行时常量池。 静态常量池：即 *.class文件中的常量池，class文件中的常量池不仅仅包含字符串（数字）字面量，还包括类，方法的信息，占用class文件的绝大空间。 运行时常量池：JVM虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，而我们常说的常量池，就是指方法区中的运行时常量池。 来看看下面的程序及结果： 12345678String s1 &#x3D; new String(&quot;hello&quot;);String s2 &#x3D; new String(&quot;hello&quot;);String s3&#x3D;&quot;hello&quot;;String s4&#x3D;&quot;hello&quot;;System.out.println(s1&#x3D;&#x3D;s2);System.out.println(s1&#x3D;&#x3D;s3);System.out.println(s3&#x3D;&#x3D;s4); falsefalsetrue 对于引用型数据，==比较的是引用型数据的地址值是否相同。上面程序new关键字一定会产生一个对象。上述程序中使用new关键字产生了两个对象（s1,s2分别指向这两个对象），保存在堆中。但在Java中不会存在完全一模一样的字符串对象，故堆中的s1,s2应该是引用字符串常量池中的“hello”。因此s1!=s2。而对于s1和s3，s1引用的是字符串常量池中“hello”的地址，s2引用的是堆中new出来的对象的地址，所以s1!=s3。s3和s4都是引用字符串常量池中“hello”的地址。 内存模型如下图： 总结s1,s2,s3,”hello”是不同的对象。String s1=new String(“hello”),虽然s1的内容是创建在堆中，但是他的内部value还是指向JVM常量池的“hello”的value。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java Java基础","slug":"Java-Java基础","permalink":"http://example.com/tags/Java-Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java对象创建过程详解","slug":"Java对象创建过程详解","date":"2021-02-22T06:59:21.000Z","updated":"2021-02-24T13:19:07.574Z","comments":true,"path":"2021/02/22/Java对象创建过程详解/","link":"","permalink":"http://example.com/2021/02/22/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"概述Java对象创建分为两个过程：声明对象和创建对象实体。类信息，对象引用，对象实体均在内存的不同区域。 内存结构每一个Java引用程序均会唯一的对应一个JVM实例，而这个JVM实例将会完成对象内存分配，程序运行，垃圾回收等工作。JVM将其内存大致分类三个区域：方法区，栈区，堆区。 方法区：是JVM在装载类文件时，用于存储类的所有描述信息的，这些信息主要包括，类的基本信息（访问修饰符，类名），字段信息（修饰符，类型，字段名），方法信息（修饰符，返回值类型，方法名，参数列表类型，异常，方法体字节码等等），常量池，静态区，classloader以及class引用。 栈区：存放局部变量，基本数据类型和对象引用类型 堆区：用于存放new产生对象的实体，每一个对象实体均会有自己的内存地址，一旦这个内存地址不被任何栈区对象引用，就会成为垃圾，随时会被GC回收。 成员变量和局部变量 成员变量：在类中方法外，存储在堆内存中，随着对象的存在而存在，随着对象的消失而消失。有默认的初始化值。 局部变量：在方法体中，存储在栈内存中，随着方法的调用而存在，随着方法的调用完毕而消失。没有默认的初始化值，所以必须先定义，赋值后才可以被使用。 对象创建过程1234567891011121314151617181920212223242526272829303132333435363738package combendy;public class Demo_04 &#123; static&#123; System.out.println(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; Inner inner1 = new Inner(); Inner inner2 = new Inner(30); System.out.println((inner1.ii==inner2.ii)+&quot; &quot;+Inner.ii); System.out.println(inner1.str==inner2.str); &#125; static class Inner&#123; private String str=&quot;hello&quot;; //成员变量 存储在堆内存中 private int i; private static int ii=10; //静态变量，存储在方法区中（这也是为什么静态变量能在多个对象共享的原因） private static int iii;// 静态代码块 static&#123; System.out.println(&quot;ii=&quot;+ii+&quot;,iii=&quot;+iii); &#125;// &#123; System.out.println(&quot;str=&quot;+str+&quot;,i=&quot;+i+&quot;,ii=&quot;+ii+&quot;,iii=&quot;+iii); &#125; public Inner()&#123; ii=20; System.out.println(&quot;non-arguments&quot;); &#125; public Inner(int i)&#123; this.i=i; System.out.println(&quot;one-arguments&quot;); &#125; &#125;&#125; 运行结果 Helloii=10,iii=0str=hello,i=0,ii=10,iii=0non-argumentsstr=hello,i=0,ii=20,iii=0one-argumentstrue 20true 步骤 将JVM加载进内存中 JVM首先检查public类是否存在，存在就会将他加载进内存方法去中，否者抛出异常，结束进程 对类中静态字段进行初始化（若无显示初始化，就会被赋值为默认值），接着执行静态代码块 在栈中创建局部变量，堆中创建对象实体，为堆对象实体的成员变量（非静态）初始化，对于静态字段只需要从方法区的静态区中引用其值即可，执行构造代码块，接着执行构造函数（这里调用顺序会一直上溯到Object类，每一个构造方法的第一行为super()语句），最后将对象实体堆地址赋值给栈中引用变量。 要注意的是，实例字段包括自身定义的和从父类继承下来的（即使父类的实例字段被子类覆盖或者被private修饰，都照样为其分配内存） C++中的引用和JAVA的引用作对比，其实他们两个只是“名称”一样，本质并没什么关系，C++中的引用只是给现存变量起了一个别名(引用变量只是一个符号引用而已，编译器并不会给引用分配新的内存)，而JAVA中的引用变量却是真真正正的变量，具有自己的内存空间，只是不同的引用变量可以“指向”同一个对象而已。因此，如果要拿C++和JAVA引用对象的方式相对比，C++中的指针倒和JAVA中的引用如出一辙，毕竟，JAVA中的引用其实就是对指针的封装","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-16T09:52:52.898Z","updated":"2021-02-16T09:52:52.898Z","comments":true,"path":"2021/02/16/hello-world/","link":"","permalink":"http://example.com/2021/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础 集合 HashCode","slug":"Java基础-集合-HashCode","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88-HashCode/"},{"name":"JavaAPI 正则表达式","slug":"JavaAPI-正则表达式","permalink":"http://example.com/tags/JavaAPI-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"JavaIO java","slug":"JavaIO-java","permalink":"http://example.com/tags/JavaIO-java/"},{"name":"Java Java基础","slug":"Java-Java基础","permalink":"http://example.com/tags/Java-Java%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}