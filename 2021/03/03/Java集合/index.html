<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java集合 | XiaoBendy</title>

  
  <meta name="author" content="XiaoBendy">
  

  
  <meta name="description" content="LinkedList类LinkedList与ArrayList不同，LinkedList是方便添加或删除的List。实际开发中对一个集合元素的添加和删除经常会涉及到首尾的操作。

LinkedList的特点是添加和删除块，但是查询慢。这是因为LinkedList是链表在添加和删除元素时，只需要修改上一个节点记录的地址值即可；而对于查询则需要遍历到要查询的元素为止。
ArrayList的特点是查询快，添加和删除慢。查询快是由于数组的索引支持，所以可以通过直接计算出元素的地址值，因此可以直接通过元素的地址值获取指定的元素；添加和删除慢是因为ArrayList在添加和删除元素时，在底层会先创建一个新数组，先需要堆数组原有的数组进行拷贝，其次在末尾进行添加或者删除元素。

LinkedList提供了大量首尾操作：">
  

  
  
  <meta name="keywords" content="Java基础 集合 HashCode">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Java集合"/>

  <meta property="og:site_name" content="XiaoBendy"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="XiaoBendy" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">XiaoBendy</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Java集合</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/03/03/Java集合/" rel="bookmark">
        <time class="entry-date published" datetime="2021-03-03T14:37:30.000Z">
          2021-03-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h1><p>LinkedList与ArrayList不同，LinkedList是方便添加或删除的List。实际开发中对一个集合元素的添加和删除经常会涉及到首尾的操作。</p>
<ul>
<li>LinkedList的特点是添加和删除块，但是查询慢。这是因为LinkedList是链表在添加和删除元素时，只需要修改上一个节点记录的地址值即可；而对于查询则需要遍历到要查询的元素为止。</li>
<li>ArrayList的特点是查询快，添加和删除慢。查询快是由于数组的索引支持，所以可以通过直接计算出元素的地址值，因此可以直接通过元素的地址值获取指定的元素；添加和删除慢是因为ArrayList在添加和删除元素时，在底层会先创建一个新数组，先需要堆数组原有的数组进行拷贝，其次在末尾进行添加或者删除元素。</li>
</ul>
<p>LinkedList提供了大量首尾操作：</p>
<a id="more"></a>

<p>public void addFirst(E e);</p>
<p>public void addLast(E e);</p>
<p>public E getFirst();</p>
<p>public E getLast();</p>
<p>代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list=<span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Trump&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        String name=list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个元素：&quot;</span>+name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回集合的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();</span><br><span class="line">        <span class="comment">//利用迭代器便利</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String thisName=it.next();</span><br><span class="line">            System.out.println(thisName);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for循环便利</span></span><br><span class="line">        <span class="keyword">for</span>(String thisName:list)&#123;</span><br><span class="line">            System.out.println(thisName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        list.remove();   <span class="comment">//默认删除第一个元素   也可以通过索引删除指定元素或者删除首尾元素</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第二个元素：Rose</span><br><span class="line">Jack</span><br><span class="line">Rose</span><br><span class="line">Trump</span><br><span class="line">------------</span><br><span class="line">Jack</span><br><span class="line">Rose</span><br><span class="line">Trump</span><br><span class="line">[Jack, Rose, Trump]</span><br><span class="line">[Rose, Trump]</span><br></pre></td></tr></table></figure>
<h2 id="LinkedList可支持栈结构"><a href="#LinkedList可支持栈结构" class="headerlink" title="LinkedList可支持栈结构"></a>LinkedList可支持栈结构</h2><p><strong><em>当然Java也提供专门用于栈结构的类Stack</em></strong></p>
<p>LinkedList对于栈结构提供了如下的方法：</p>
<blockquote>
<p>push 压栈</p>
<p>pop 弹栈</p>
<p>peek 查询出即将要出栈的元素（栈顶元素），检查有没有要弹出的元素,当栈为空时就返回空值。</p>
</blockquote>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        stack.push(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;Lisa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取一个元素 此时，由于是栈结构 所以获取的是最后压栈的元素</span></span><br><span class="line">        String popName=stack.pop(); <span class="comment">//这里获取的是Lisa元素</span></span><br><span class="line">        System.out.println(popName);</span><br><span class="line"></span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">        String peekName=stack.peek();</span><br><span class="line">        System.out.println(peekName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//peek查看元素不会减少元素</span></span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Lisa, Rose, Jack]</span><br><span class="line">Lisa</span><br><span class="line">[Rose, Jack]</span><br><span class="line">Rose</span><br><span class="line">[Rose, Jack]</span><br></pre></td></tr></table></figure>
<p><strong>注意这里输出栈时，是从栈顶到栈底依次输出</strong></p>
<h2 id="LinkedList可支持队列结构"><a href="#LinkedList可支持队列结构" class="headerlink" title="LinkedList可支持队列结构"></a>LinkedList可支持队列结构</h2><p>LinkedList为支持队列元素提供了如下的方法：</p>
<blockquote>
<p>offer 加入队列</p>
<p>poll 离开队列</p>
<p>peek 查询出即将要离开队列的元素（即队首元素），可检查有没有要离开队列的元素,当队列为空时返回空值null</p>
</blockquote>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;Lisa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队首元素</span></span><br><span class="line">        String pollName=queue.poll();</span><br><span class="line">        System.out.println(pollName);</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        String peekName=queue.peek();</span><br><span class="line">        System.out.println(peekName);</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空队列</span></span><br><span class="line">        queue.remove();</span><br><span class="line">        queue.remove();</span><br><span class="line">        <span class="comment">//检查是否还有要离开的元素</span></span><br><span class="line">        String name=queue.peek();</span><br><span class="line">        System.out.println(name);   <span class="comment">//队列为空时  peek()返回的是空值null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Jack, Rose, Lisa]</span><br><span class="line">Jack</span><br><span class="line">[Rose, Lisa]</span><br><span class="line">Rose</span><br><span class="line">[Rose, Lisa]</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h1 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h1><p>HashSet是Set接口的子类，不包括重复相同的元素，*<strong>并且是无序的**<em>，且提供索引，所以不能通过索引获取元素，</em></strong>只能通过迭代器访问数据***</p>
<p>HashSet下还有子类LinkedHashSet,<strong>是可预测迭代顺序</strong>的Set的集合。</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Lisa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);   <span class="comment">//输出是无序的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素，只能迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String name = it.next();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历set集合</span></span><br><span class="line">        <span class="keyword">for</span>(String name:set)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Rose, Jack, Lisa]</span><br><span class="line">Rose</span><br><span class="line">Jack</span><br><span class="line">Lisa</span><br><span class="line">============</span><br><span class="line">Rose</span><br><span class="line">Jack</span><br><span class="line">Lisa</span><br></pre></td></tr></table></figure>
<p><strong><em>注意这里输出结果是无序的，还要记住不能通过索引来访问只能使用迭代器来访问数据</em></strong></p>
<p>HashSet的简单应用：使用HashSet求一个字符串中一共有几个不重复的字母，区分大小写,比如a，A是算两个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        s=scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建HashSet集合</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串拆分成一个个单个字符</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:chars)&#123;</span><br><span class="line">            <span class="comment">//判断是否是字母</span></span><br><span class="line">            <span class="keyword">if</span>((ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>)||(ch&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">                set.add(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;在该字符串中总共有&quot;</span>+set.size()+<span class="string">&quot;个不重复的字母。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ArrayList中使用contains方法判断是否有重复元素"><a href="#ArrayList中使用contains方法判断是否有重复元素" class="headerlink" title="ArrayList中使用contains方法判断是否有重复元素"></a>ArrayList中使用contains方法判断是否有重复元素</h2><p>自定义类型Person是Object类的子类，所以Person具备equals方法，而contains方法会调用equals方法，依次与集合当中已经存在的Person对象比较。   当Person类没有重写equals方法时，直接使用Object类继承过来的equals方法，而该方法比较的是对象的地址值。当Person类重写equals方法后，就可以将比较规则由比较地址值改为比较属性值。</p>
<p>下面代码是没有重写equals的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList_contains</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Person jack = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">        Person rose = <span class="keyword">new</span> Person(<span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.add(jack);</span><br><span class="line">        list.add(rose);</span><br><span class="line">	<span class="comment">//这里没有重写equals方法 所以比较的是地址值 因此返回的是False  若重写equals方法比较的是name和age的成员变量则返回true</span></span><br><span class="line">        System.out.println(list.contains(p));  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码是Person类中重写equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Person p=(Person)obj;</span><br><span class="line">        <span class="keyword">if</span>(p.getName()==getName()&amp;&amp;p.getAge()==getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重写之后在运行上面代码会发现返回的结果是true。</p>
<h2 id="HashSet判断元素唯一性准则"><a href="#HashSet判断元素唯一性准则" class="headerlink" title="HashSet判断元素唯一性准则"></a><strong>HashSet判断元素唯一性准则</strong></h2><p>Set集合不能添加重复元素，那其添加方法在添加是判断是否有重复元素，那其判断规则是怎么样的呢？？？</p>
<p>HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法返回的结果。</p>
<p>规则如下：</p>
<p>把对象加入到HashSet时，它会先使用对象的hashCode值来判断对象加入的位置；</p>
<p>如果此位置上没有其他对象存在，则判断元素不同，可存入新对象。</p>
<p>如果此位置有对象存在，先判断新元素与集合内已经有的旧元素的HashCode值：如果不同，判断为是不同的对象，可存入新对象；如果相同，在判断equals比较结果，返回true相同，则不可存入新对象；返回是的false则仍然不同，即可存入新对象。</p>
<p>所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的地址值，如果想通过内容比较元素是否相同，则需要重写该类的hashCode与equals方法。</p>
<p>hashCode方法重写规则：<br>    将对象的各个属性值的hashCode相加即是整个对象的HashCode值。<br>    如果是基本类型，类似int，则直接返回int值就是该属性的hash值；<br>    如果是引用类型，类似String，就调用该成员变量的hashCode方法返回该成员变量的hash值。</p>
<p>这样可以根据对象的内容返回hashCode值，从而可以根据hashCode判断元素是否唯一。<br>但是由于一些“碰巧的”情况下，可能出现内容不同但hashCode相同的情况，为了避免这些情况，我们要加入一些干扰系数。<br>可是加入干扰系数后，仍会出现一些“碰巧”的情况，所以我们还要进行equals的二次判断。</p>
<p>重写hashCode方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thisHashCode</span><br><span class="line">    thisHashCode+=name.hashCode()*<span class="number">17</span>;</span><br><span class="line">    thisHashCode+=age.hashCode</span><br><span class="line">    <span class="keyword">return</span> thisHashCo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java集合框架之总结-amp-体系图"><a href="#Java集合框架之总结-amp-体系图" class="headerlink" title="Java集合框架之总结&amp;体系图"></a>Java集合框架之总结&amp;体系图</h1><h2 id="单列集合体系图"><a href="#单列集合体系图" class="headerlink" title="单列集合体系图"></a>单列集合体系图</h2><p><img src="/2021/03/03/Java%E9%9B%86%E5%90%88/image.png" alt="集合框架体系图"></p>
<p>Collection：所有单列集合的直接或间接接口，其指定了所有集合应该具备的基本功能。<br>List：元素可重复，有序，带索引。<br>Set：元素不可重复，无序，没有索引。<br>ArrayList：底层是数组结构，ArrayList的出现代替了Vector，增删慢，查看快。<br>LinkedList：底层是链表结构，同事对元素的增删操作效率高。<br>HashSet：底层是哈希表结构。在不重复的基础上无序。<br>LinkedHashSet：底层是哈希表结构结合链表结构，在不重复的基础上可预测迭代顺序。</p>
<h2 id="集合的常见使用"><a href="#集合的常见使用" class="headerlink" title="集合的常见使用"></a>集合的常见使用</h2><p>在设计集合的使用时，经常定义对应的接口类型。在使用时，通过多态的方式给接口变量赋值，用于提高程序扩展性。</p>
<p>如：定义方法public void method(List list){}，在调用方法是依据需求，传入ArrayList或LinkedList的对象。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Java基础/">Java基础</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java基础-集合-HashCode/">Java基础 集合 HashCode</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 XiaoBendy
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>